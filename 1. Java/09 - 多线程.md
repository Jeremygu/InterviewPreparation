## 九、 多线程

https://www.nowcoder.com/profile/7404313/test/8066549/26053?onlyWrong=0

### 问：进程和线程的区别是什么？

进程资源分配的基本单位，而线程是CPU调度的基本单位。一个进程可以有多个线程，多个线程共享进程的资源，线程又叫做轻量级进程。

### 问：概括的解释下线程的几种可用状态。

<center>
<img src="./Java-Pic/thread-state.png" width="85%"/>
</center>

**(1) 新建(new)**：新创建了一个线程对象。

**(2) 可运行(runnable)**：线程对象创建后，其他线程(比如main线程)调用了该对象的start()方法，该状态的线程便位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。

**(3) 运行(running)**：可运行状态(runnable)的线程获得了cpu时间片(timeslice)，执行程序代码。

**(4) 阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：
> 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
> 
> 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
> 
> 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。            

当sleep()状态超时、 join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

**(5) 死亡(dead)**：线程run()、 main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

### 问：创建线程有几种不同的方式？你喜欢哪一种？为什么？

有三种方式可以用来创建线程：继承Thread类、实现Runnable接口，重写它们的run()方法。

实现Runnable接口这种方式更受欢迎。在应用设计中线程类已经继承了别的类的情况下，需要多继承，只能实现接口（而Java不支持多继承，却支持实现多个接口），这样就不再需要继承Thread类，避免单继承的局限。同时，线程池也是非常高效的，很容易实现和使用。

https://www.nowcoder.com/profile/7404313/test/8078128/25818?onlyWrong=0

https://www.nowcoder.com/questionTerminal/fefb0691a35444198c36e8ce0d19c8d9 看评论

### 问：start()和run()

无论是通过继承Thread类还是实现Runnable接口来创建线程，都必须调用start()方法启动线程。线程启动后，线程进入就绪状态，当CPU分配时间给它时，它才开始运行。

并不是一调用start()方法线程就立即运行。

### 同步和异步

同步：上一段代码没的完成，下一段必须等到上一段代码完成后才可以执行。如买票排队
异步：上一段代码没的完成，下一段不必等到上一段代码完成就可以执行。如手机发送短信。

#### 16. 什么是死锁(deadlock)？

两个线程或两个以上线程因争夺资源而都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是若无外力作用，这些线程都陷入了无限的等待中。

#### 17. 如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定访问资源的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

#### 15. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

在Java虚拟机中, 每个对象(Object和class)通过某种逻辑关联监视器，每个监视器和一个对象引用相关联；为了实现监视器的互斥功能，每个对象都关联着一把锁。因此在Java虚拟机中监视器和锁是一块使用的。      

一旦方法或者代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码。

https://www.nowcoder.com/profile/7404313/test/8066549/3206?onlyWrong=0

### 问：synchronized

https://www.nowcoder.com/profile/7404313/test/7977669/56323#summary

https://www.nowcoder.com/profile/7404313/test/7906972/14929?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/7993658/15544?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8078128/16017?onlyWrong=0

15、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
如只其它方法是同步方法，不可以进入。如果不是可以进入。

### 问：同步方法和同步代码块的区别是什么？

Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(增删改查)，将会导致数据的不准确，相互之间产生冲突。因此加入了同步锁，以避免在该线程没有结束前，其他线程操作该资源变量，从而保证了变量的唯一性，准确性。

Java中每个对象都有一把锁，线程可以通过synchronized关键字来获取对象上的锁。

**(1) 同步方法(粗粒度锁)：**:由synchronized关键字修饰的方法，同步方法默认用this或者当前类class对象作为锁
> 修饰一般方法:public synchronized void method(){...}，获取的是当前调用对象this上的锁
>  
> 修饰静态方法:public static synchronized void method(){...}，获取当前类的字节码对象上的锁 

**(2) 同步代码块(细粒度锁)：**: 由synchronized关键字修饰的语句块，同步代码块可以选择以什么语句块来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法
> synchronized(obj) {...}，同步代码块可以指定获取哪个对象上的锁。

### 24、请说出你所知道的线程同步的方法
HashTable中的put,get,remove
Vector的相关方法。

### Java支持并发编程的同步机制

https://www.nowcoder.com/profile/7404313/test/7977669/7696?onlyWrong=0

### 问：wait、notify、notifyAll

- wait()

(1) 该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。

(2) 在调用wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。如果调用wait()时，线程没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。

(3) 进入wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。

- notify()

(1) 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用notify()时线程没有持有适当的锁，也会抛出IllegalMonitorStateException。

(2) 该方法用来唤醒那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程调度器任意挑选出其中一个wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，发出通知的当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。

(3) 当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify 语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。

- notifyAll()

该方法与 notify ()方法的工作方式相同，重要的一点差异是：
notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），开始等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。

总结：如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

案例：当前线程调用对象的notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁。

	public static void main(String[]args)throws Exception {
	    final Object obj = new Object();
	    Thread t1 = new Thread() {
	        public void run() {
	            synchronized (obj) {
	                try {
	                    obj.wait();
	                    System.out.println("Thread 1 wake up.");
	                } catch (InterruptedException e) {
	                }
	            }
	        }
	    };
	    t1.start();
	    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.
	    Thread t2 = new Thread() {
	        public void run() {
	            synchronized (obj) {
	                obj.notifyAll();
	                System.out.println("Thread 2 sent notify.");
	            }
	        }
	    };
	    t2.start();
	}

	output:
	Thread 2 sent notify.
	Thread 1 wake up

https://www.nowcoder.com/profile/7404313/test/8045843/7689?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8088719/3255?onlyWrong=0

## 问：sleep()和wait()的区别

sleep()：该方法让线程休眠指定的时间，当这个时间达到之后，线程会再次醒来。

wait()：该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。

(1) sleep()是Thread类的方法，wait()是Object类的方法

(2) wait()，notify()和notifyAll()只能在同步方法或同步代码块中使用，而sleep()可以在任何地方使用

(3) 调用sleep()方法后，线程进入睡眠状态，但不会释放对象锁；调用wait()方法后，线程会释放对象锁，进入此对象的等待锁池中。

https://www.nowcoder.com/profile/7404313/test/8073294/15267?onlyWrong=0

### join()

### stop()和suspend()

4、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
Extends Thread(继承自Thread类)
Implements Runnable（实现Runnable接口）
同步
Public synchronized aa()
{

}


Public void cc(object aa)
{
	synchronized(aa)
{
}
}

用synchoronized修饰同步方法。

答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口
同步的实现方面有两种，分别是synchronized,wait与notify
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

### 问：Java四种线程池的使用

应用程序可以使用Executor/Callable/Future框架来创建线程池。

(1) ExecutorService java.util.concurrent.Executors.newSingleThreadExecutor()

Creates an Executor that uses a single worker thread operating off an unbounded queue. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads.

Returns:
the newly created single-threaded Executor

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

示例代码：

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class NewSingleThreadExecutor {
		public static void main(String[] args) {
			ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
			for (int i = 0; i < 10; i++) {
				final int index = i;
				singleThreadExecutor.execute(new Runnable() {
					public void run() {
						try {
							System.out.println(index);
							Thread.sleep(2000);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				});
			}
		}
	}
	
	// 顺序执行各个任务，依次输出结果

(2) ExecutorService java.util.concurrent.Executors.newFixedThreadPool(int nThreads)

创建一个含有固定数量线程的线程池，可控制最大并发任务数，超出的任务会在队列中等待。

`Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown.

Parameters:
nThreads the number of threads in the pool

Returns:
the newly created thread pool

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class NewFixedThreadPool {
		public static void main(String[] args) {
			ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
			for (int i = 0; i < 10; i++) {
				final int index = i;
				fixedThreadPool.execute(new Runnable() {
					public void run() {
						try {
							System.out.println(index);
							Thread.sleep(2000);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				});
			}
		}
	}

	// 因为线程池大小为3，每个线程输出index后sleep 2秒，所以每隔两秒打印3个数字

(3) ExecutorService java.util.concurrent.Executors.newCachedThreadPool()

Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.

Returns:
the newly created thread pool

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class ThreadPoolExecutorTest {
		public static void main(String[] args) {
			ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
			for (int i = 0; i < 10; i++) {
				final int index = i;
				try {
					Thread.sleep(index * 1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				cachedThreadPool.execute(new Runnable() {
					public void run() {
						System.out.println(index);
					}
				});
			}
		}
	}


(4) ScheduledExecutorService java.util.concurrent.Executors.newScheduledThreadPool(int corePoolSize)

创建一个含有固定数量线程的线程池，支持延时任务或周期性任务的执行。

Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.

Parameters:
corePoolSize the number of threads to keep in the pool, even if they are idle
Returns:
a newly created scheduled thread pool
Throws:
IllegalArgumentException - if corePoolSize < 0

执行延时任务的示例代码：

	import java.util.concurrent.Executors;
	import java.util.concurrent.ScheduledExecutorService;
	import java.util.concurrent.TimeUnit;
	
	public class NewScheduledThreadPool1 {
		public static void main(String[] args) {
			ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
			scheduledThreadPool.schedule(new Runnable() {
				public void run() {
					System.out.println("delay 3 seconds");
				}
			}, 3, TimeUnit.SECONDS);
		}
	}

	// 表示延迟3秒执行任务

执行定期性任务的示例代码：

	import java.util.concurrent.Executors;
	import java.util.concurrent.ScheduledExecutorService;
	import java.util.concurrent.TimeUnit;
	
	public class NewScheduledThreadPool2 {
		public static void main(String[] args) {
			ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
			scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
				public void run() {
					System.out.println("delay 1 seconds, and excute every 3 seconds");
				}
			}, 1, 3, TimeUnit.SECONDS);
		}
	}

	// 表示延迟1秒后，每3秒执行一次任务

### volatile

https://www.nowcoder.com/profile/7404313/test/8004321/25776?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8070641/22468?onlyWrong=0

### ThreadLocal

https://www.nowcoder.com/profile/7404313/test/7977669/14506?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8049404/7691?onlyWrong=0
























