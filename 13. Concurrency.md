### 问：并发与并行

	两个线程并发执行以下代码，假设a是全局变量，初始为1，那么执行完下列语句后的输出可能为：3 2，2 3，3 3和2 2
	void foo(){
	    ++a;
	    printf("%d ",a);
	}

	解释还不是特别清楚
	https://www.nowcoder.com/profile/7404313/test/8115789/3939?onlyWrong=0

	https://www.nowcoder.com/profile/7404313/test/8120272/3356

	https://www.nowcoder.com/profile/7404313/test/8120272/4607?onlyWrong=0

### 问：进程同步

为禁止两个进程同时进入临界区，**同步机制应该遵循一下基本准则**：
 
- 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
- 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
- 有限等待：对要求访问临界资源的进程，应保证能在有限的时间内进入临界区。
- 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，防止进程忙等待。

### 问：死锁

**死锁产生的原因**

系统资源的竞争，资源出现循环等待

https://www.nowcoder.com/profile/7404313/test/8067759/14356?onlyWrong=0

**死锁产生的必要条件**

- 互斥条件：一个资源在一段时间内仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待。
- 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。
- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不妨。
- 循环等待条件：存在一种资源的进程循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{P1, P2, ..., Pn}，其中Pi等待的资源被P(i+1)占有，Pn等待的资源被P0占有。

**死锁的处理策略**

(1) 死锁预防：破坏产生死锁的四个必要条件中的一个或几个，防止发生死锁。

(2) 死锁避免：死锁避免同样属于事先预防的策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。

银行家算法是最著名的死锁避免算法。

(3) 死锁检测

### 问：共享内存

共享内存是进程间通信的一种方式。尽管每个进程都有自己的内存地址，但是不同的进程可以同时将同一个内存页面映射到自己的地址空间中，所有进程都可以访问共享内存中的地址，从而达到共享内存的目的。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。**共享内存并未提供同步机制**，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要使用像信号量这样的同步机制来限制对共享内存的访问。

## 其他

### 问：无锁化编程

https://www.nowcoder.com/profile/7404313/test/8120272/4043?onlyWrong=0